[{"file": "DSA.docx", "chunk_id": 0, "text": "\ud83d\udccc Topics to Cover in DSA Here\u2019s a structured plan: 1\ufe0f\u20e3 Arrays & Strings Basics: Declaration, Initialization, Access Searching: Linear Search, Binary Search Sorting: Bubble, Selection, Insertion, Merge, Quick Sort Two Pointers Technique Sliding Window (e.g., Longest Substring Without Repeating Characters) Kadane\u2019s Algorithm (Maximum Subarray Sum) Prefix Sum & Difference Array 2\ufe0f\u20e3 Linked List Singly & Doubly Linked List (Insertion, Deletion, Traversal) Detect Loop in Linked List (Floyd\u2019s Cycle Detection) Reverse a Linked List Merge Two Sorted Linked Lists 3\ufe0f\u20e3 Stack & Queue Stack (LIFO): Push, Pop, Peek Queue (FIFO): Enqueue, Dequeue Circular Queue Implement Stack using Queue and Vice Versa Balanced Parentheses Problem Next Greater Element 4\ufe0f\u20e3 Recursion & Backtracking Factorial, Fibonacci, Tower of Hanoi Subset Generation N-Queens Problem Rat in a Maze Sudoku Solver 5\ufe0f\u20e3 Trees & Binary Search Tree (BST) Tree Traversals (Inorder, Preorder, Postorder) Height of a Tree Lowest Common Ancestor (LCA) Check if a Tree is Balanced Binary Search Tree (BST) Operations 6\ufe0f\u20e3 Graphs BFS & DFS Traversal Dijkstra\u2019s Algorithm (Shortest Path) Cycle Detection Topological Sorting Connected Components 7\ufe0f\u20e3 Dynamic Programming (DP) Fibonacci Series using DP Knapsack Problem (0/1 Knapsack) Longest Common Subsequence Coin Change Problem 1\ufe0f\u20e3 Arrays in C++ Definition: An array is a collection of elements of the same data type stored in contiguous memory locations. It allows storing multiple values under a single variable name. Why Use Arrays? \u2705 Efficient for storing and accessing large amounts of data. \u2705 Provides direct access to elements using an index. \u2705 Useful for implementing data structures like stacks, queues, and matrices. Why Not Use Arrays? \u274c Fixed size, meaning it cannot be resized dynamically. \u274c Insertion and deletion operations are inefficient (except at the end). \u274c Requires manual memory management for dynamic arrays. Topics Related to Arrays: 1\ufe0f\u20e3 Basic Array Operations 2\ufe0f\u20e3 Searching Algorithms (Linear Search, Binary Search) 3\ufe0f\u20e3 Sorting Algorithms (Bubble Sort, Selection Sort, Merge Sort, Quick Sort) 4\ufe0f\u20e3 Two Pointers Technique 5\ufe0f\u20e3 Sliding Window Technique 6\ufe0f\u20e3 Kadane\u2019s Algorithm (Maximum Subarray Sum) 1\ufe0f\u20e3 Basic Array Operations in C++ Declaring and Initializing an Array cpp CopyEdit #include <iostream> using namespace std; int main() { int arr[5] = {10, 20, 30, 40, 50}; // Initializing an array cout << \"First element: \" << arr[0] << endl; // Accessing an element return 0; } Traversing an Array cpp CopyEdit #include <iostream> using namespace std; int main() { int arr[] = {1, 2, 3, 4, 5}; int n"}, {"file": "DSA.docx", "chunk_id": 1, "text": "= sizeof(arr) / sizeof(arr[0]); // Finding size of array cout << \"Array Elements: \"; for (int i = 0; i < n; i++) { cout << arr[i] << \" \"; } return 0; } 2\ufe0f\u20e3 Searching Algorithms in Arrays \ud83d\udd39 Linear Search (O(n)) Checks each element one by one. cpp CopyEdit #include <iostream> using namespace std; int linearSearch(int arr[], int n, int key) { for (int i = 0; i < n; i++) { if (arr[i] == key) return i; // Element found } return -1; // Element not found } int main() { int arr[] = {10, 20, 30, 40, 50}; int n = sizeof(arr) / sizeof(arr[0]); int key = 30; int index = linearSearch(arr, n, key); if (index != -1) cout << \"Element found at index \" << index; else cout << \"Element not found\"; return 0; } \ud83d\udd39 Binary Search (O(log n)) Works only on sorted arrays. cpp CopyEdit #include <iostream> using namespace std; int binarySearch(int arr[], int left, int right, int key) { while (left <= right) { int mid = left + (right - left) / 2; if (arr[mid] == key) return mid; else if (arr[mid] < key) left = mid + 1; else right = mid - 1; } return -1; } int main() { int arr[] = {10, 20, 30, 40, 50}; int n = sizeof(arr) / sizeof(arr[0]); int key = 30; int index = binarySearch(arr, 0, n - 1, key); if (index != -1) cout << \"Element found at index \" << index; else cout << \"Element not found\"; return 0; } 1\ufe0f\u20e3 Sorting Algorithms What is Sorting? Sorting is the process of arranging elements in a specific order (ascending or descending). Sorting helps improve data organization, search efficiency, and optimization in various algorithms. Types of Sorting Algorithms Sorting algorithms can be categorized into different types based on their approach: Comparison-Based Sorting: Bubble Sort Selection Sort Insertion Sort Merge Sort Quick Sort Heap Sort Non-Comparison-Based Sorting: Counting Sort Radix Sort Bucket Sort \ud83d\udd39 Bubble Sort (O(n\u00b2)) Definition: Bubble Sort repeatedly compares adjacent elements and swaps them if they are in the wrong order. The largest elements \"bubble up\" to the right place. Explanation: Start from the first element and compare it with the next one. Swap if necessary. Repeat the process for all elements. Reduce the range for the next pass since the largest elements are already sorted. cpp CopyEdit #include <iostream>"}, {"file": "DSA.docx", "chunk_id": 2, "text": "using namespace std; void bubbleSort(int arr[], int n) { for (int i = 0; i < n - 1; i++) { for (int j = 0; j < n - i - 1; j++) { if (arr[j] > arr[j + 1]) { swap(arr[j], arr[j + 1]); } } } } int main() { int arr[] = {64, 25, 12, 22, 11}; int n = sizeof(arr) / sizeof(arr[0]); bubbleSort(arr, n); cout << \"Sorted array: \"; for (int i = 0; i < n; i++) cout << arr[i] << \" \"; return 0; } \ud83d\udd39 Selection Sort (O(n\u00b2)) Definition: Selection Sort repeatedly selects the smallest element from the unsorted part and swaps it with the first unsorted element. Explanation: Find the smallest element in the array. Swap it with the first element. Repeat for the remaining elements. cpp CopyEdit #include <iostream> using namespace std; void selectionSort(int arr[], int n) { for (int i = 0; i < n - 1; i++) { int minIndex = i; for (int j = i + 1; j < n; j++) { if (arr[j] < arr[minIndex]) { minIndex = j; } } swap(arr[i], arr[minIndex]); } } int main() { int arr[] = {64, 25, 12, 22, 11}; int n = sizeof(arr) / sizeof(arr[0]); selectionSort(arr, n); cout << \"Sorted array: \"; for (int i = 0; i < n; i++) cout << arr[i] << \" \"; return 0; } \ud83d\udd39 Insertion Sort (O(n\u00b2)) Definition: Insertion Sort builds the sorted list one element at a time by picking each element and placing it at the correct position. Explanation: Start from the second element. Compare it with the previous elements. Shift larger elements to the right. Insert the current element in its correct position. cpp CopyEdit #include <iostream> using namespace std; void insertionSort(int arr[], int n) { for (int i = 1; i < n; i++) { int key = arr[i]; int j = i - 1; while (j >= 0 && arr[j] > key) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = key; } } int main() { int arr[] = {64, 25, 12, 22, 11}; int n = sizeof(arr) / sizeof(arr[0]); insertionSort(arr, n); cout << \"Sorted array: \"; for (int i = 0; i < n; i++) cout << arr[i] << \" \"; return 0; } \ud83d\udd39 Merge Sort (O(n log n)) Definition: Merge Sort is a divide-and-conquer algorithm that divides the array"}, {"file": "DSA.docx", "chunk_id": 3, "text": "into halves, sorts them, and merges them. Explanation: Divide the array into two halves. Recursively sort each half. Merge the two sorted halves. cpp CopyEdit #include <iostream> using namespace std; void merge(int arr[], int left, int mid, int right) { int n1 = mid - left + 1, n2 = right - mid; int L[n1], R[n2]; for (int i = 0; i < n1; i++) L[i] = arr[left + i]; for (int i = 0; i < n2; i++) R[i] = arr[mid + 1 + i]; int i = 0, j = 0, k = left; while (i < n1 && j < n2) { if (L[i] <= R[j]) arr[k++] = L[i++]; else arr[k++] = R[j++]; } while (i < n1) arr[k++] = L[i++]; while (j < n2) arr[k++] = R[j++]; } void mergeSort(int arr[], int left, int right) { if (left < right) { int mid = left + (right - left) / 2; mergeSort(arr, left, mid); mergeSort(arr, mid + 1, right); merge(arr, left, mid, right); } } int main() { int arr[] = {64, 25, 12, 22, 11}; int n = sizeof(arr) / sizeof(arr[0]); mergeSort(arr, 0, n - 1); cout << \"Sorted array: \"; for (int i = 0; i < n; i++) cout << arr[i] << \" \"; return 0; } \ud83d\udd39 Quick Sort (O(n log n)) Definition: Quick Sort is a divide-and-conquer algorithm that picks a pivot element, partitions the array around it, and recursively sorts the subarrays. Explanation: Select a pivot. Partition the array into elements smaller and greater than the pivot. Recursively sort the partitions. cpp CopyEdit #include <iostream> using namespace std; int partition(int arr[], int low, int high) { int pivot = arr[high]; int i = low - 1; for (int j = low; j < high; j++) { if (arr[j] < pivot) { i++; swap(arr[i], arr[j]); } } swap(arr[i + 1], arr[high]); return i + 1; } void quickSort(int arr[], int low, int high) { if (low < high) { int pi = partition(arr, low, high); quickSort(arr, low, pi - 1); quickSort(arr, pi + 1, high); } } int main() { int arr[] = {64, 25, 12, 22, 11}; int n = sizeof(arr) / sizeof(arr[0]); quickSort(arr, 0, n - 1); cout << \"Sorted array: \"; for (int i = 0; i < n; i++) cout << arr[i] << \" \"; return 0; }"}]